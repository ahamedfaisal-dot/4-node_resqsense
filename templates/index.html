<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ResQSense | Underground Mining Safety Monitor | Real-Time Sensor Dashboard</title>
    <!-- Socket.IO removed for Windows compatibility - using polling instead -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 3.5em;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 800;
        }

        .header h2 {
            font-size: 2em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            color: #ffffff;
            font-weight: 600;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .connected {
            background: #4CAF50;
            color: white;
        }

        .disconnected {
            background: #f44336;
            color: white;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .gas-charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .chart-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
        }

        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
            z-index: 10;
        }

        .status-normal {
            background: #4CAF50;
            color: white;
        }

        .status-warning {
            background: #ff9800;
            color: white;
        }

        .status-danger {
            background: #f44336;
            color: white;
        }

        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
            z-index: 10;
        }

        .status-normal {
            background: #4CAF50;
            color: white;
        }

        .status-warning {
            background: #ff9800;
            color: white;
        }

        .status-danger {
            background: #f44336;
            color: white;
        }

        .full-width-chart {
            grid-column: 1 / -1;
        }

        .gas-charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }



        .refresh-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }



        @media (max-width: 768px) {
            .charts-grid, .gas-charts-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .header h2 {
                font-size: 1.5em;
            }
            
            .container {
                padding: 10px;
            }
            
            .node-grid {
                grid-template-columns: 1fr;
            }
            
            .node-card {
                flex-direction: column;
                text-align: center;
            }
            
            .map-container {
                height: 300px;
            }
            
            .map-legend {
                position: relative;
                bottom: auto;
                left: auto;
                margin-top: 20px;
                text-align: center;
            }
        }



        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .safety-info {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }

        .safety-info h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .safety-info p {
            color: #666;
            font-size: 0.9em;
            line-height: 1.4;
        }

        #acceleration3D {
            border-radius: 10px;
            overflow: hidden;
            background: #f8f9fa;
        }

        #acceleration3D canvas {
            border-radius: 10px;
        }

        .footer {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px 0;
            margin-top: 40px;
            backdrop-filter: blur(10px);
        }

        .footer-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .footer-brand h3 {
            color: #4ecdc4;
            margin-bottom: 10px;
            font-size: 1.5em;
        }

        .footer-brand p {
            color: #ccc;
            font-size: 0.9em;
        }

        .footer-info {
            text-align: right;
        }

        .footer-info p {
            color: #ccc;
            font-size: 0.8em;
            margin: 5px 0;
        }

        /* Node Overview Styles */
        .node-overview {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .node-overview h3 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.4em;
        }

        .node-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .node-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .node-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .node-icon {
            font-size: 2em;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
        }

        .node-info {
            flex: 1;
        }

        .node-info h4 {
            margin: 0 0 5px 0;
            font-size: 1.2em;
        }

        .node-info p {
            margin: 0 0 10px 0;
            opacity: 0.9;
            font-size: 0.9em;
        }

        .node-status {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: bold;
            text-align: center;
        }

        .node-arrow {
            font-size: 1.5em;
            opacity: 0.8;
        }

        /* Mining Map Styles */
        .mining-map-section {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .mining-map-section h3 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.4em;
        }

        .mining-map {
            display: flex;
            justify-content: center;
        }

        .map-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 400px;
            background: linear-gradient(180deg, #2c3e50 0%, #34495e 50%, #2c3e50 100%);
            border-radius: 15px;
            overflow: hidden;
            border: 3px solid #34495e;
        }

        .map-surface {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 2px solid #654321;
        }

        .surface-label {
            color: white;
            font-weight: bold;
            font-size: 1.1em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .map-shafts {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .main-shaft {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 80px;
            background: linear-gradient(180deg, #555 0%, #333 100%);
            border-left: 3px solid #222;
            border-right: 3px solid #222;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .shaft-label {
            position: absolute;
            top: 20px;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .east-tunnel {
            position: absolute;
            left: 50%;
            top: 150px;
            width: 200px;
            height: 60px;
            transform: translateX(-100%);
        }

        .west-tunnel {
            position: absolute;
            left: 50%;
            top: 250px;
            width: 200px;
            height: 60px;
            transform: translateX(0);
        }

        .tunnel-path {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(90deg, #555 0%, #333 100%);
            border-radius: 10px;
            border: 2px solid #222;
        }

        .node-point {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node-point:hover {
            transform: translateY(-50%) scale(1.2);
        }

        .node1 {
            left: 50%;
            top: 100px;
            transform: translateX(-50%);
        }

        .node2 {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .node3 {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .node-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            animation: pulse 2s infinite;
        }

        .node1 .node-dot {
            background: #ff4444;
        }

        .node2 .node-dot {
            background: #ffaa00;
        }

        .node3 .node-dot {
            background: #44ff44;
        }

        .node-label {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: bold;
            white-space: nowrap;
        }

        .map-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ddd;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-dot {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid white;
        }

        .legend-dot.node1 {
            background: #ff4444;
        }

        .legend-dot.node2 {
            background: #ffaa00;
        }

        .legend-dot.node3 {
            background: #44ff44;
        }

        @media (max-width: 768px) {
            .footer-content {
                flex-direction: column;
                text-align: center;
            }
            
            .footer-info {
                text-align: center;
            }
        }
        
        /* Node switch animations */
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        /* Navigation Buttons Styles */
.main-navigation {
    position: fixed;
    top: 20px;
    left: 20px;
    display: flex;
    gap: 15px;
    z-index: 1000;
}

.nav-btn {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 25px;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.2);
    display: flex;
    align-items: center;
    gap: 8px;
    text-decoration: none;
}

.nav-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    background: linear-gradient(135deg, #5a67d8 0%, #6c5ce7 100%);
    color: white;
}

.nav-btn.active {
    background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
    border: 2px solid rgba(255,255,255,0.4);
    box-shadow: 0 6px 25px rgba(78, 205, 196, 0.4);
}

.nav-btn-icon {
    font-size: 16px;
}

@media (max-width: 768px) {
    .main-navigation {
        position: relative;
        top: 0;
        left: 0;
        justify-content: center;
        margin-bottom: 20px;
        flex-wrap: wrap;
    }
    
    .nav-btn {
        padding: 10px 16px;
        font-size: 13px;
    }
}

    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">
        <span id="statusText">Connecting...</span>
    </div>

    <div class="container">
        <div class="header">
            <h1>⛏️ ResQSense</h1>
            <h2>Underground Mining Safety Monitor</h2>
            <p>Multi-Node Real-time Sensor Monitoring with WebSocket Streaming & Safety Compliance</p>
        </div>

        <div class="safety-info">
            <h3>⚠️ ResQSense Safety Compliance - Underground Mining Standards</h3>
            <p><strong>MQ4 (Methane CH₄):</strong> Normal: 0-300 ppm, Warning: 300-1000 ppm, Danger: >1000 ppm</p>
            <p><strong>MQ5 (LPG/Propane):</strong> Normal: 0-400 ppm, Warning: 400-800 ppm, Danger: >800 ppm</p>
            <p><strong>MQ135 (Air Quality):</strong> Normal: 0-350 ppm, Warning: 350-700 ppm, Danger: >700 ppm</p>
            <p><strong>MQ7 (Carbon Monoxide CO):</strong> Normal: 0-200 ppm, Warning: 200-400 ppm, Danger: >400 ppm</p>
        </div>

        <div class="node-overview">
            <h3>🏭 Active Mining Nodes Overview</h3>
            <div class="node-grid">
                <div class="node-card" onclick="navigateToNode(1)">
                    <div class="node-icon">🔴</div>
                    <div class="node-info">
                        <h4>Node 1</h4>
                        <p>Main Shaft - Level 1</p>
                        <div class="node-status" id="node1Status">Online</div>
                    </div>
                    <div class="node-arrow">→</div>
                </div>
                <div class="node-card" onclick="navigateToNode(2)">
                    <div class="node-icon">🟡</div>
                    <div class="node-info">
                        <h4>Node 2</h4>
                        <p>East Tunnel - Level 2</p>
                        <div class="node-status" id="node2Status">Online</div>
                    </div>
                    <div class="node-arrow">→</div>
                </div>
                <div class="node-card" onclick="navigateToNode(3)">
                    <div class="node-icon">🟢</div>
                    <div class="node-info">
                        <h4>Node 3</h4>
                        <p>West Tunnel - Level 3</p>
                        <div class="node-status" id="node3Status">Online</div>
                    </div>
                    <div class="node-arrow">→</div>
                </div>
            </div>
        </div>

        <button class="refresh-btn" onclick="refreshData()">🔄 Refresh Historical Data</button>

        <div class="mining-map-section">
            <h3>🗺️ Underground Mining Layout</h3>
            <div class="mining-map">
                <div class="map-container">
                    <div class="map-surface">
                        <div class="surface-label">Surface Level</div>
                    </div>
                    <div class="map-shafts">
                        <div class="main-shaft">
                            <div class="shaft-label">Main Shaft</div>
                            <div class="node-point node1" onclick="navigateToNode(1)" title="Node 1 - Main Shaft Level 1">
                                <div class="node-dot"></div>
                                <div class="node-label">N1</div>
                            </div>
                        </div>
                        <div class="east-tunnel">
                            <div class="tunnel-path"></div>
                            <div class="node-point node2" onclick="navigateToNode(2)" title="Node 2 - East Tunnel Level 2">
                                <div class="node-dot"></div>
                                <div class="node-label">N2</div>
                            </div>
                        </div>
                        <div class="west-tunnel">
                            <div class="tunnel-path"></div>
                            <div class="node-point node3" onclick="navigateToNode(3)" title="Node 3 - West Tunnel Level 3">
                                <div class="node-dot"></div>
                                <div class="node-label">N3</div>
                            </div>
                        </div>
                    </div>
                    <div class="map-legend">
                        <div class="legend-item">
                            <div class="legend-dot node1"></div>
                            <span>Node 1 - Main Shaft</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot node2"></div>
                            <span>Node 2 - East Tunnel</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot node3"></div>
                            <span>Node 3 - West Tunnel</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="stats-grid" id="statsGrid">
            <div class="stat-card">
                <div class="stat-value pulse" id="totalReadings">-</div>
                <div class="stat-label">Total Readings</div>
            </div>
            <div class="stat-card">
                <div class="stat-value pulse" id="avgTemperature">-</div>
                <div class="stat-label">Avg Temperature</div>
            </div>
            <div class="stat-card">
                <div class="stat-value pulse" id="avgHumidity">-</div>
                <div class="stat-label">Avg Humidity</div>
            </div>
            <div class="stat-card">
                <div class="stat-value pulse" id="lastUpdate">-</div>
                <div class="stat-label">Last Update</div>
            </div>
        </div>

        <div class="charts-grid">
            <div class="chart-container">
                <div class="chart-title">🌡️ Temperature</div>
                <div class="status-indicator status-normal" id="temperatureStatus">NORMAL</div>
                <canvas id="temperatureChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">💧 Humidity</div>
                <div class="status-indicator status-normal" id="humidityStatus">NORMAL</div>
                <canvas id="humidityChart"></canvas>
            </div>
        </div>

        <div class="charts-grid">
            <div class="chart-container">
                <div class="chart-title">📊 Sound & Pressure</div>
                <div class="status-indicator status-normal" id="soundPressureStatus">NORMAL</div>
                <canvas id="soundPressureChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">📳 3D Acceleration Model</div>
                <div class="status-indicator status-normal" id="accelerationStatus">NORMAL</div>
                <div id="acceleration3D" style="width: 100%; height: 300px;"></div>
                <div style="text-align: center; margin-top: 10px; font-size: 0.8em; color: #666;">
                    🖱️ Click and drag to rotate view • 🔴 Red arrow shows acceleration vector
                </div>
            </div>
        </div>

        <div class="gas-charts-grid">
            <div class="chart-container">
                <div class="chart-title">💨 MQ4 - Methane (CH₄)</div>
                <div class="status-indicator status-normal" id="mq4Status">NORMAL</div>
                <canvas id="mq4Chart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">🔥 MQ5 - LPG/Propane</div>
                <div class="status-indicator status-normal" id="mq5Status">NORMAL</div>
                <canvas id="mq5Chart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">🌬️ MQ135 - Air Quality</div>
                <div class="status-indicator status-normal" id="mq135Status">NORMAL</div>
                <canvas id="mq135Chart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">☠️ MQ7 - Carbon Monoxide (CO)</div>
                <div class="status-indicator status-normal" id="mq7Status">NORMAL</div>
                <canvas id="mq7Chart"></canvas>
            </div>
        </div>

        <div class="charts-grid">
            <div class="chart-container">
                <div class="chart-title">🔥 Fire Detection</div>
                <div class="status-indicator status-normal" id="fireStatus">NORMAL</div>
                <canvas id="fireChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">📳 Vibration Detection</div>
                <div class="status-indicator status-normal" id="vibrationStatus">NORMAL</div>
                <canvas id="vibrationChart"></canvas>
            </div>
        </div>




    </div>

    <div class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-brand">
                    <h3>⛏️ ResQSense</h3>
                    <p>Advanced Underground Mining Safety Monitoring System</p>
                </div>
                <div class="footer-info">
                    <p>Real-time sensor monitoring • WebSocket streaming • Safety compliance</p>
                    <p>© 2025 ResQSense - Protecting miners through technology</p>
                </div>
            </div>
        </div>
    </div>
    <div class="main-navigation">
    <a href="#dashboard" class="nav-btn">
        <span class="nav-btn-icon">📊</span>
        <span>Dashboard</span>
    </a>
    <a href="#mining-map-section" class="nav-btn">
        <span class="nav-btn-icon">🗺️</span>
        <span>Map</span>
    </a>
    <a href="http://10.2.0.2:5000/" class="nav-btn">
        <span class="nav-btn-icon">⌚</span>
        <span>Smart Band</span>
    </a>
</div>

    <script>
        // Polling-based data updates (Windows compatible)
        let charts = {};
        let dataBuffer = [];
        const MAX_DATA_POINTS = 50;
        let pollingInterval;
        
        // Multi-node data storage
        let nodeData = {
            node_1: [],
            node_2: [],
            node_3: []
        };
        
        // Current active node
        let activeNode = 'node_1';

        // Underground mining safety thresholds
        const SAFETY_THRESHOLDS = {
            MQ4: { normal: 300, warning: 1000, danger: 1000 },      // Methane
            MQ5: { normal: 400, warning: 800, danger: 800 },        // LPG/Propane
            MQ135: { normal: 350, warning: 700, danger: 700 },      // Air Quality
            MQ7: { normal: 200, warning: 400, danger: 400 }         // Carbon Monoxide
        };

        // Polling-based data updates (Windows compatible)
        function startPolling() {
            console.log('Starting polling for real-time data...');
            updateConnectionStatus('connected', 'Polling Active');
            
            // Poll every 2 seconds
            pollingInterval = setInterval(() => {
                fetchLatestData();
            }, 2000);
        }
        
        function stopPolling() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
                console.log('Polling stopped');
                updateConnectionStatus('disconnected', 'Polling Stopped');
            }
        }
        
        function fetchLatestData() {
            // Fetch more data points for the active node to maintain buffer
            fetch(`/data?node=${activeNode}&limit=20`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.data && data.data.length > 0) {
                        console.log(`Received ${data.data.length} data points via polling for ${activeNode}`);
                        
                        // Process all received data to maintain buffer
                        data.data.forEach(dataPoint => {
                            processIncomingData(dataPoint);
                        });
                        
                        // Update charts with the latest data
                        if (data.data.length > 0) {
                            const latestData = data.data[0];
                            updateCharts(latestData);
                            updateStats();
                            updateSafetyStatuses(latestData);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                    updateConnectionStatus('disconnected', 'Connection Error');
                });
        }
        
        function fetchLatestDataForRefresh() {
            // Fetch data for refresh button (without updating stats)
            fetch(`/data?node=${activeNode}&limit=20`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.data && data.data.length > 0) {
                        console.log(`Refresh: Received ${data.data.length} data points for ${activeNode}`);
                        
                        // Process all received data to maintain buffer
                        data.data.forEach(dataPoint => {
                            processIncomingData(dataPoint);
                        });
                        
                        // Update charts with the latest data (but not stats)
                        if (data.data.length > 0) {
                            const latestData = data.data[0];
                            updateCharts(latestData);
                            updateSafetyStatuses(latestData);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching data for refresh:', error);
                });
        }
        
        function processIncomingData(data) {
            // Check if data has node information
            let nodeId = data.node_id || 'node_1';
            
            console.log('Processing data for nodeId:', nodeId);
            console.log('Current activeNode:', activeNode);
            
            // Store data for the specific node
            if (!nodeData[nodeId]) {
                nodeData[nodeId] = [];
                console.log('Created new data buffer for node:', nodeId);
            }
            
            // Add timestamp if not present
            if (!data.timestamp) {
                data.timestamp = Date.now();
            }
            
            // Check if this data point already exists (avoid duplicates)
            const existingIndex = nodeData[nodeId].findIndex(d => d.id === data.id);
            if (existingIndex === -1) {
                // Store in node-specific buffer (newest first)
                nodeData[nodeId].unshift({
                    ...data,
                    timestamp: data.timestamp
                });
                
                console.log('Data buffer for', nodeId, 'now has', nodeData[nodeId].length, 'entries');
                
                // Keep only latest data for each node
                if (nodeData[nodeId].length > MAX_DATA_POINTS) {
                    nodeData[nodeId] = nodeData[nodeId].slice(0, MAX_DATA_POINTS);
                }
                
                // Add to current active node if it matches
                if (nodeId === activeNode) {
                    console.log('Updating charts for active node:', nodeId);
                    addDataPoint(data);
                    updateStats();
                    updateSafetyStatuses(data);
                } else {
                    console.log('Node', nodeId, 'is not active, storing data only');
                }
            } else {
                console.log('Data point already exists, skipping duplicate');
            }
            
            // Update node status
            updateNodeStatus(nodeId, 'Online');
        }

        function updateNodeStatus(nodeId, status) {
            // Extract node number from nodeId (handle node_1, node_2, node_3 format)
            let nodeNumber = nodeId.replace('node_', '');
            
            const statusElement = document.getElementById(`node${nodeNumber}Status`);
            if (statusElement) {
                statusElement.textContent = status;
                if (status === 'Online') {
                    statusElement.style.background = 'rgba(76, 175, 80, 0.8)';
                } else {
                    statusElement.style.background = 'rgba(244, 67, 54, 0.8)';
                }
            }
        }

        function updateConnectionStatus(status, text) {
            const statusElement = document.getElementById('connectionStatus');
            const statusTextElement = document.getElementById('statusText');
            
            statusElement.className = `connection-status ${status}`;
            statusTextElement.textContent = text;
        }

        function navigateToNode(nodeNumber) {
            // Convert to the format used in the backend (node_1, node_2, node_3)
            const nodeKey = `node_${nodeNumber}`;
            console.log(`Navigating to ${nodeKey}`);
            
            // Store current data for the previous active node
            if (dataBuffer.length > 0 && activeNode) {
                nodeData[activeNode] = [...dataBuffer];
                console.log(`Stored ${dataBuffer.length} data points for ${activeNode}`);
            }
            
            // Update active node
            activeNode = nodeKey;
            console.log(`Active node changed to: ${activeNode}`);
            
            // Clear current charts and data
            dataBuffer = [];
            Object.values(charts).forEach(chart => {
                if (chart && chart.data) {
                    chart.data.labels = [];
                    chart.data.datasets.forEach(dataset => {
                        dataset.data = [];
                    });
                    chart.update('none');
                }
            });
            
            // Load node-specific data
            if (nodeData[nodeKey] && nodeData[nodeKey].length > 0) {
                dataBuffer = [...nodeData[nodeKey]];
                console.log(`Loaded ${dataBuffer.length} data points for ${nodeKey}`);
                
                // Update charts with historical data
                dataBuffer.forEach(data => {
                    updateCharts(data);
                });
                updateStats();
                if (dataBuffer.length > 0) {
                    updateSafetyStatuses(dataBuffer[dataBuffer.length - 1]);
                }
            } else {
                console.log(`No data found for ${nodeKey}`);
            }
            
            // Update UI to show active node
            updateActiveNodeUI(nodeNumber);
            
            // Scroll to charts section
            document.querySelector('.charts-grid').scrollIntoView({ behavior: 'smooth' });
            
            console.log(`Successfully switched to ${nodeKey}, current dataBuffer length: ${dataBuffer.length}`);
        }

        function updateActiveNodeUI(nodeNumber) {
            // Update page title
            document.title = `ResQSense | Node ${nodeNumber} | Underground Mining Safety Monitor`;
            
            // Update header
            const headerH2 = document.querySelector('.header h2');
            headerH2.innerHTML = `Underground Mining Safety Monitor - <span style="color: #4ecdc4;">Node ${nodeNumber}</span>`;
            
            // Update node status indicators
            document.querySelectorAll('.node-card').forEach((card, index) => {
                if (index === nodeNumber - 1) {
                    card.style.transform = 'scale(1.05)';
                    card.style.boxShadow = '0 8px 25px rgba(0,0,0,0.4)';
                    card.style.border = '3px solid #4ecdc4';
                    card.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                } else {
                    card.style.transform = 'scale(1)';
                    card.style.boxShadow = '0 4px 15px rgba(0,0,0,0.2)';
                    card.style.border = '2px solid rgba(255,255,255,0.1)';
                    card.style.background = 'linear-gradient(135deg, #2c3e50 0%, #34495e 100%)';
                }
            });
            
            // Update mining map node highlighting
            document.querySelectorAll('.node-point').forEach((point, index) => {
                if (index === nodeNumber - 1) {
                    point.style.transform = 'scale(1.3)';
                    point.style.filter = 'drop-shadow(0 0 15px rgba(255,255,255,0.8))';
                    point.style.background = '#4ecdc4';
                    point.style.border = '3px solid #fff';
                } else {
                    point.style.transform = 'scale(1)';
                    point.style.filter = 'none';
                    point.style.background = '#95a5a6';
                    point.style.border = '2px solid rgba(255,255,255,0.3)';
                }
            });
            
            // Add visual feedback message
            showNodeSwitchMessage(`Switched to Node ${nodeNumber}`);
        }
        
        function showNodeSwitchMessage(message) {
            // Remove existing message
            const existingMessage = document.querySelector('.node-switch-message');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            // Create new message
            const messageDiv = document.createElement('div');
            messageDiv.className = 'node-switch-message';
            messageDiv.textContent = message;
            messageDiv.style.cssText = `
                position: fixed;
                top: 100px;
                right: 20px;
                background: linear-gradient(135deg, #4ecdc4, #44a08d);
                color: white;
                padding: 15px 25px;
                border-radius: 25px;
                box-shadow: 0 8px 25px rgba(0,0,0,0.3);
                z-index: 1000;
                font-weight: bold;
                animation: slideInRight 0.5s ease-out;
            `;
            
            document.body.appendChild(messageDiv);
            
            // Remove message after 3 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.style.animation = 'slideOutRight 0.5s ease-in';
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.remove();
                        }
                    }, 500);
                }
            }, 3000);
        }

        function getSafetyStatus(value, thresholds) {
            if (value <= thresholds.normal) return 'status-normal';
            if (value <= thresholds.warning) return 'status-warning';
            return 'status-danger';
        }

        function getSafetyText(value, thresholds) {
            if (value <= thresholds.normal) return 'NORMAL';
            if (value <= thresholds.warning) return 'WARNING';
            return 'DANGER';
        }

        function updateSafetyStatuses(data) {
            // Update MQ4 status
            const mq4Status = document.getElementById('mq4Status');
            const mq4Class = getSafetyStatus(data.MQ4 || 0, SAFETY_THRESHOLDS.MQ4);
            const mq4Text = getSafetyText(data.MQ4 || 0, SAFETY_THRESHOLDS.MQ4);
            mq4Status.className = `status-indicator ${mq4Class}`;
            mq4Status.textContent = mq4Text;

            // Update MQ5 status
            const mq5Status = document.getElementById('mq5Status');
            const mq5Class = getSafetyStatus(data.MQ5 || 0, SAFETY_THRESHOLDS.MQ5);
            const mq5Text = getSafetyText(data.MQ5 || 0, SAFETY_THRESHOLDS.MQ5);
            mq5Status.className = `status-indicator ${mq5Class}`;
            mq5Status.textContent = mq5Text;

            // Update MQ135 status
            const mq135Status = document.getElementById('mq135Status');
            const mq135Class = getSafetyStatus(data.MQ135 || 0, SAFETY_THRESHOLDS.MQ135);
            const mq135Text = getSafetyText(data.MQ135 || 0, SAFETY_THRESHOLDS.MQ135);
            mq135Status.className = `status-indicator ${mq135Class}`;
            mq135Status.textContent = mq135Text;

            // Update MQ7 status
            const mq7Status = document.getElementById('mq7Status');
            const mq7Class = getSafetyStatus(data.MQ7 || 0, SAFETY_THRESHOLDS.MQ7);
            const mq7Text = getSafetyText(data.MQ7 || 0, SAFETY_THRESHOLDS.MQ7);
            mq7Status.className = `status-indicator ${mq7Class}`;
            mq7Status.textContent = mq7Text;

            // Update Fire status
            const fireStatus = document.getElementById('fireStatus');
            if (data.Fire > 0) {
                fireStatus.className = 'status-indicator status-danger';
                fireStatus.textContent = 'FIRE DETECTED';
            } else {
                fireStatus.className = 'status-indicator status-normal';
                fireStatus.textContent = 'NORMAL';
            }

            // Update Vibration status
            const vibrationStatus = document.getElementById('vibrationStatus');
            if (data.Vibration > 0) {
                vibrationStatus.className = 'status-indicator status-warning';
                vibrationStatus.textContent = 'VIBRATION DETECTED';
            } else {
                vibrationStatus.className = 'status-indicator status-normal';
                vibrationStatus.textContent = 'NORMAL';
            }
        }

        function addDataPoint(data) {
            // Check if this data point already exists in dataBuffer
            const existingIndex = dataBuffer.findIndex(d => d.id === data.id);
            if (existingIndex === -1) {
                const timestamp = new Date(data.timestamp || Date.now());
                dataBuffer.unshift({
                    timestamp: timestamp,
                    ...data
                });

                // Keep only the latest MAX_DATA_POINTS
                if (dataBuffer.length > MAX_DATA_POINTS) {
                    dataBuffer = dataBuffer.slice(0, MAX_DATA_POINTS);
                }
            }
        }

        function initializeCharts() {
            console.log('Initializing charts...');
            
            // Check if Chart.js is loaded
            if (typeof Chart === 'undefined') {
                console.error('Chart.js not loaded!');
                return;
            }
            
            // Check if canvas elements exist
            const tempCanvas = document.getElementById('temperatureChart');
            const humidityCanvas = document.getElementById('humidityChart');
            
            if (!tempCanvas || !humidityCanvas) {
                console.error('Canvas elements not found!');
                return;
            }
            
            console.log('Canvas elements found, creating charts...');
            
            // Individual Temperature Chart
            charts.temperature = new Chart(tempCanvas, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Temperature (°C)',
                        data: [],
                        borderColor: '#ff6384',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Temperature (°C)'
                            }
                        }
                    }
                }
            });

            // Individual Humidity Chart
            charts.humidity = new Chart(document.getElementById('humidityChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Humidity (%)',
                        data: [],
                        borderColor: '#36a2eb',
                        backgroundColor: 'rgba(54, 162, 235, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Humidity (%)'
                            }
                        }
                    }
                }
            });

            // Individual MQ4 Chart
            charts.mq4 = new Chart(document.getElementById('mq4Chart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Methane (CH₄) ppm',
                        data: [],
                        borderColor: '#ff6384',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Concentration (ppm)'
                            }
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: {
                                normalLine: {
                                    type: 'line',
                                    yMin: SAFETY_THRESHOLDS.MQ4.normal,
                                    yMax: SAFETY_THRESHOLDS.MQ4.normal,
                                    borderColor: '#4CAF50',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                warningLine: {
                                    type: 'line',
                                    yMin: SAFETY_THRESHOLDS.MQ4.warning,
                                    yMax: SAFETY_THRESHOLDS.MQ4.warning,
                                    borderColor: '#ff9800',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                }
                            }
                        }
                    }
                }
            });

            // Individual MQ5 Chart
            charts.mq5 = new Chart(document.getElementById('mq5Chart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'LPG/Propane ppm',
                        data: [],
                        borderColor: '#ff9f40',
                        backgroundColor: 'rgba(255, 159, 64, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Concentration (ppm)'
                            }
                        }
                    }
                }
            });

            // Individual MQ135 Chart
            charts.mq135 = new Chart(document.getElementById('mq135Chart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Air Quality ppm',
                        data: [],
                        borderColor: '#4bc0c0',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Concentration (ppm)'
                            }
                        }
                    }
                }
            });

            // Individual MQ7 Chart
            charts.mq7 = new Chart(document.getElementById('mq7Chart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Carbon Monoxide (CO) ppm',
                        data: [],
                        borderColor: '#9966ff',
                        backgroundColor: 'rgba(153, 102, 255, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Concentration (ppm)'
                            }
                        }
                    }
                }
            });

            // Sound & Pressure Chart
            charts.soundPressure = new Chart(document.getElementById('soundPressureChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Sound',
                        data: [],
                        borderColor: '#ffcd56',
                        backgroundColor: 'rgba(255, 205, 86, 0.1)',
                        tension: 0.4,
                        yAxisID: 'y'
                    }, {
                        label: 'Pressure (kPa)',
                        data: [],
                        borderColor: '#c9cbcf',
                        backgroundColor: 'rgba(201, 203, 207, 0.1)',
                        tension: 0.4,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Sound Level'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Pressure (kPa)'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    }
                }
            });

            // Fire Detection Chart
            charts.fire = new Chart(document.getElementById('fireChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Fire Detection',
                        data: [],
                        borderColor: '#ff4444',
                        backgroundColor: 'rgba(255, 68, 68, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointBackgroundColor: function(context) {
                            const value = context.raw;
                            return value > 0 ? '#ff0000' : '#00ff00';
                        },
                        pointBorderColor: function(context) {
                            const value = context.raw;
                            return value > 0 ? '#cc0000' : '#00cc00';
                        }
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1,
                            ticks: {
                                stepSize: 1,
                                callback: function(value) {
                                    return value === 0 ? 'No Fire' : 'FIRE DETECTED';
                                }
                            },
                            title: {
                                display: true,
                                text: 'Fire Status'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    return value > 0 ? '🔥 FIRE DETECTED' : '✅ No Fire';
                                }
                            }
                        }
                    }
                }
            });

            // Vibration Detection Chart
            charts.vibration = new Chart(document.getElementById('vibrationChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Vibration Detection',
                        data: [],
                        borderColor: '#ff8800',
                        backgroundColor: 'rgba(255, 136, 0, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointBackgroundColor: function(context) {
                            const value = context.raw;
                            return value > 0 ? '#ff6600' : '#00cc00';
                        },
                        pointBorderColor: function(context) {
                            const value = context.raw;
                            return value > 0 ? '#cc5500' : '#00aa00';
                        }
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1,
                            ticks: {
                                stepSize: 1,
                                callback: function(value) {
                                    return value === 0 ? 'No Vibration' : 'VIBRATION DETECTED';
                                }
                            },
                            title: {
                                display: true,
                                text: 'Vibration Status'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    return value > 0 ? '📳 VIBRATION DETECTED' : '✅ No Vibration';
                                }
                            }
                        }
                    }
                }
            });

            // Initialize 3D Acceleration Model
            initialize3DAcceleration();
        }

        function initialize3DAcceleration() {
            const container = document.getElementById('acceleration3D');
            
            // Create scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            // Create camera
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            
            // Create renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            // Create coordinate system with labels
            const axesHelper = new THREE.AxesHelper(3);
            scene.add(axesHelper);
            
            // Add axis labels
            const xLabel = createTextSprite('X', 3.5, 0, 0);
            const yLabel = createTextSprite('Y', 0, 3.5, 0);
            const zLabel = createTextSprite('Z', 0, 0, 3.5);
            scene.add(xLabel);
            scene.add(yLabel);
            scene.add(zLabel);
            
            // Create acceleration vector arrow
            const arrowGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1, 8);
            const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.position.set(0, 0.5, 0);
            scene.add(arrow);
            
            // Create arrow head
            const coneGeometry = new THREE.ConeGeometry(0.05, 0.1, 8);
            const coneMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.position.set(0, 1, 0);
            scene.add(cone);
            
            // Add grid for better orientation
            const gridHelper = new THREE.GridHelper(6, 6, 0x888888, 0xcccccc);
            scene.add(gridHelper);
            
            // Store references for updates
            charts.acceleration3D = {
                scene: scene,
                camera: camera,
                renderer: renderer,
                arrow: arrow,
                cone: cone
            };
            
            // Add mouse controls for rotation
            let isMouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            
            container.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            container.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            container.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    camera.position.x = 5 * Math.cos(deltaX * 0.01);
                    camera.position.z = 5 * Math.sin(deltaX * 0.01);
                    camera.position.y = 5 + deltaY * 0.01;
                    
                    camera.lookAt(0, 0, 0);
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            });
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }

        function createTextSprite(text, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = 'Bold 20px Arial';
            context.fillStyle = '#000000';
            context.fillText(text, 0, 20);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(0.5, 0.25, 1);
            
            return sprite;
        }

        function update3DAcceleration(acceleration) {
            if (!charts.acceleration3D) return;
            
            const { arrow, cone } = charts.acceleration3D;
            
            // Calculate magnitude and direction
            const x = acceleration.x || 0;
            const y = acceleration.y || 0;
            const z = acceleration.z || 0;
            
            // Calculate magnitude (length of vector)
            const magnitude = Math.sqrt(x * x + y * y + z * z);
            
            // Scale the arrow based on magnitude
            const scale = Math.min(magnitude * 2, 3); // Cap at 3 units
            
            // Update arrow scale
            arrow.scale.set(1, scale, 1);
            cone.scale.set(1, 1, 1);
            
            // Position cone at the end of the arrow
            cone.position.set(0, scale, 0);
            
            // Calculate rotation to point in the direction of acceleration
            if (magnitude > 0.1) {
                const direction = new THREE.Vector3(x, y, z).normalize();
                const up = new THREE.Vector3(0, 1, 0);
                
                // Create rotation matrix
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.lookAt(new THREE.Vector3(0, 0, 0), direction, up);
                
                // Apply rotation to both arrow and cone
                arrow.setRotationFromMatrix(rotationMatrix);
                cone.setRotationFromMatrix(rotationMatrix);
                
                // Adjust cone position after rotation
                cone.position.copy(direction.clone().multiplyScalar(scale));
            }
        }

        function updateCharts(newData) {
            const timestamp = new Date(newData.timestamp || Date.now());
            const timeLabel = timestamp.toLocaleTimeString();

            // Update Individual Temperature Chart
            if (charts.temperature) {
                charts.temperature.data.labels.push(timeLabel);
                charts.temperature.data.datasets[0].data.push(newData.Temperature || 0);
                
                if (charts.temperature.data.labels.length > MAX_DATA_POINTS) {
                    charts.temperature.data.labels.shift();
                    charts.temperature.data.datasets[0].data.shift();
                }
                charts.temperature.update('none');
            }

            // Update Individual Humidity Chart
            if (charts.humidity) {
                charts.humidity.data.labels.push(timeLabel);
                charts.humidity.data.datasets[0].data.push(newData.Humidity || 0);
                
                if (charts.humidity.data.labels.length > MAX_DATA_POINTS) {
                    charts.humidity.data.labels.shift();
                    charts.humidity.data.datasets[0].data.shift();
                }
                charts.humidity.update('none');
            }

            // Update Individual MQ4 Chart
            if (charts.mq4) {
                charts.mq4.data.labels.push(timeLabel);
                charts.mq4.data.datasets[0].data.push(newData.MQ4 || 0);
                
                if (charts.mq4.data.labels.length > MAX_DATA_POINTS) {
                    charts.mq4.data.labels.shift();
                    charts.mq4.data.datasets[0].data.shift();
                }
                charts.mq4.update('none');
            }

            // Update Individual MQ5 Chart
            if (charts.mq5) {
                charts.mq5.data.labels.push(timeLabel);
                charts.mq5.data.datasets[0].data.push(newData.MQ5 || 0);
                
                if (charts.mq5.data.labels.length > MAX_DATA_POINTS) {
                    charts.mq5.data.labels.shift();
                    charts.mq5.data.datasets[0].data.shift();
                }
                charts.mq5.update('none');
            }

            // Update Individual MQ135 Chart
            if (charts.mq135) {
                charts.mq135.data.labels.push(timeLabel);
                charts.mq135.data.datasets[0].data.push(newData.MQ135 || 0);
                
                if (charts.mq135.data.labels.length > MAX_DATA_POINTS) {
                    charts.mq135.data.labels.shift();
                    charts.mq135.data.datasets[0].data.shift();
                }
                charts.mq135.update('none');
            }

            // Update Individual MQ7 Chart
            if (charts.mq7) {
                charts.mq7.data.labels.push(timeLabel);
                charts.mq7.data.datasets[0].data.push(newData.MQ7 || 0);
                
                if (charts.mq7.data.labels.length > MAX_DATA_POINTS) {
                    charts.mq7.data.labels.shift();
                    charts.mq7.data.datasets[0].data.shift();
                }
                charts.mq7.update('none');
            }

            // Update Sound & Pressure Chart
            if (charts.soundPressure) {
                charts.soundPressure.data.labels.push(timeLabel);
                charts.soundPressure.data.datasets[0].data.push(newData.Sound || 0);
                charts.soundPressure.data.datasets[1].data.push((newData.Pressure || 0) / 1000); // Convert to kPa
                
                if (charts.soundPressure.data.labels.length > MAX_DATA_POINTS) {
                    charts.soundPressure.data.labels.shift();
                    charts.soundPressure.data.datasets[0].data.shift();
                    charts.soundPressure.data.datasets[1].data.shift();
                }
                charts.soundPressure.update('none');
            }

            // Update Fire Detection Chart
            if (charts.fire) {
                charts.fire.data.labels.push(timeLabel);
                charts.fire.data.datasets[0].data.push(newData.Fire || 0);
                
                if (charts.fire.data.labels.length > MAX_DATA_POINTS) {
                    charts.fire.data.labels.shift();
                    charts.fire.data.datasets[0].data.shift();
                }
                charts.fire.update('none');
            }

            // Update Vibration Detection Chart
            if (charts.vibration) {
                charts.vibration.data.labels.push(timeLabel);
                charts.vibration.data.datasets[0].data.push(newData.Vibration || 0);
                
                if (charts.vibration.data.labels.length > MAX_DATA_POINTS) {
                    charts.vibration.data.labels.shift();
                    charts.vibration.data.datasets[0].data.shift();
                }
                charts.vibration.update('none');
            }

            // Update 3D Acceleration Model
            if (charts.acceleration3D && newData.Acceleration) {
                update3DAcceleration(newData.Acceleration);
            }
        }



        function updateStats() {
            if (dataBuffer.length > 0) {
                const latest = dataBuffer[dataBuffer.length - 1];
                const avgTemp = dataBuffer.reduce((sum, d) => sum + (d.Temperature || 0), 0) / dataBuffer.length;
                const avgHumidity = dataBuffer.reduce((sum, d) => sum + (d.Humidity || 0), 0) / dataBuffer.length;
                
                document.getElementById('totalReadings').textContent = dataBuffer.length;
                document.getElementById('avgTemperature').textContent = `${avgTemp.toFixed(1)}°C`;
                document.getElementById('avgHumidity').textContent = `${avgHumidity.toFixed(1)}%`;
                document.getElementById('lastUpdate').textContent = new Date(latest.timestamp || Date.now()).toLocaleTimeString();
            } else {
                // If no data in buffer, show dashes
                document.getElementById('totalReadings').textContent = '-';
                document.getElementById('avgTemperature').textContent = '-';
                document.getElementById('avgHumidity').textContent = '-';
                document.getElementById('lastUpdate').textContent = '-';
            }
        }

        function refreshData() {
            console.log('Manual refresh requested...');
            // Update stats from server
            fetch('/stats')
                .then(response => response.json())
                .then(statsData => {
                    if (statsData.status === 'success') {
                        console.log('Received stats from server:', statsData.stats);
                        document.getElementById('totalReadings').textContent = statsData.stats.total_records;
                        document.getElementById('avgTemperature').textContent = `${statsData.stats.average_temperature}°C`;
                        document.getElementById('avgHumidity').textContent = `${statsData.stats.average_humidity}%`;
                        document.getElementById('lastUpdate').textContent = statsData.stats.latest_timestamp ? 
                            new Date(statsData.stats.latest_timestamp).toLocaleString() : 'N/A';
                    }
                })
                .catch(error => console.error('Error fetching stats:', error));
            
            // Fetch latest data for current node (but don't update stats again)
            fetchLatestDataForRefresh();
        }

        // Initialize charts when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');
            initializeCharts();
            refreshData();
            
            // Set default active node
            updateActiveNodeUI(1);
            
            // Start polling for real-time data
            startPolling();
            
            // Simulate node data for demonstration
            setTimeout(() => {
                simulateNodeData();
            }, 1000);
            
            // Add test data to verify charts are working
            setTimeout(() => {
                console.log('Adding test data to verify charts...');
                const testData = {
                    Temperature: 25,
                    Humidity: 60,
                    MQ4: 200,
                    MQ5: 300,
                    MQ135: 400,
                    MQ7: 150,
                    Sound: 45,
                    Fire: 0,
                    Vibration: 0,
                    Pressure: 101325,
                    Acceleration: {x: 1.2, y: -0.8, z: 9.8},
                    timestamp: Date.now()
                };
                addDataPoint(testData);
                updateCharts(testData);
                updateStats();
                updateSafetyStatuses(testData);
                console.log('Test data added to charts');
                
                // Debug: Check chart objects
                console.log('Charts object:', charts);
                console.log('Temperature chart:', charts.temperature);
                if (charts.temperature && charts.temperature.data) {
                    console.log('Temperature chart data:', charts.temperature.data);
                }
            }, 2000);
        });

        function simulateNodeData() {
            // Simulate data for all nodes
            const nodes = ['node_1', 'node_2', 'node_3'];
            nodes.forEach((nodeId, index) => {
                const mockData = {
                    node_id: nodeId,
                    timestamp: Date.now() - (index * 1000),
                    MQ4: Math.floor(Math.random() * 800) + 200,
                    MQ5: Math.floor(Math.random() * 600) + 300,
                    MQ135: Math.floor(Math.random() * 500) + 200,
                    MQ7: Math.floor(Math.random() * 300) + 100,
                    Temperature: Math.floor(Math.random() * 20) + 25,
                    Humidity: Math.floor(Math.random() * 30) + 50,
                    Sound: Math.floor(Math.random() * 50),
                    Fire: Math.random() > 0.8 ? 1 : 0,
                    Vibration: Math.random() > 0.7 ? 1 : 0,
                    Pressure: Math.floor(Math.random() * 20000) + 90000,
                    Acceleration: {
                        x: (Math.random() - 0.5) * 4,
                        y: (Math.random() - 0.5) * 4,
                        z: (Math.random() - 0.5) * 4
                    }
                };
                
                nodeData[nodeId] = [mockData];
                updateNodeStatus(nodeId, 'Online');
                
                // Also add to active node if it matches
                if (nodeId === activeNode) {
                    addDataPoint(mockData);
                    updateCharts(mockData);
                    updateStats();
                    updateSafetyStatuses(mockData);
                }
            });
        }
    </script>
</body>
</html>
