<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rover Radar Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            overflow: hidden;
            height: 100vh;
        }

        .dashboard {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            position: relative;
        }

        .title {
            position: absolute;
            top: 20px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff00;
            z-index: 10;
        }

        .radar-container {
            position: relative;
            width: 700px;
            height: 700px;
        }

        .radar-svg {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0,100,0,0.1) 0%, rgba(0,50,0,0.05) 50%, transparent 100%);
            border-radius: 50%;
        }

        .connection-status {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
        }

        .connected {
            background: rgba(0,255,0,0.2);
            border: 1px solid #00ff00;
            color: #00ff00;
        }

        .disconnected {
            background: rgba(255,0,0,0.2);
            border: 1px solid #ff4444;
            color: #ff4444;
        }

        .data-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #00ff00;
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            min-width: 250px;
        }

        .sensor-readings {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #00ff00;
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            min-width: 200px;
        }

        .reading-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .alert { color: #ff4444; }
        .warning { color: #ffaa00; }
        .safe { color: #00ff00; }

        @keyframes sweep {
            0% { transform: rotate(0deg); opacity: 1; }
            100% { transform: rotate(360deg); opacity: 0.3; }
        }

        @keyframes radarPulse {
            0% { opacity: 1; }
            100% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <div class="title">AUTONOMOUS ROVER RADAR SYSTEM</div>
        
        <div class="connection-status" id="connectionStatus">
            <span id="statusText">CONNECTING...</span>
        </div>

        <div class="radar-container">
            <svg class="radar-svg" viewBox="0 0 700 700" xmlns="http://www.w3.org/2000/svg">
                <!-- Background circles -->
                <circle cx="350" cy="350" r="100" fill="none" stroke="rgba(0,255,0,0.3)" stroke-width="1"/>
                <circle cx="350" cy="350" r="150" fill="none" stroke="rgba(0,255,0,0.3)" stroke-width="1"/>
                <circle cx="350" cy="350" r="200" fill="none" stroke="rgba(0,255,0,0.3)" stroke-width="1"/>
                <circle cx="350" cy="350" r="250" fill="none" stroke="rgba(0,255,0,0.3)" stroke-width="1"/>
                <circle cx="350" cy="350" r="300" fill="none" stroke="rgba(0,255,0,0.3)" stroke-width="1"/>
                
                <!-- Cross lines -->
                <line x1="50" y1="350" x2="650" y2="350" stroke="rgba(0,255,0,0.3)" stroke-width="1"/>
                <line x1="350" y1="50" x2="350" y2="650" stroke="rgba(0,255,0,0.3)" stroke-width="1"/>
                
                <!-- Diagonal lines -->
                <line x1="102" y1="102" x2="598" y2="598" stroke="rgba(0,255,0,0.2)" stroke-width="1"/>
                <line x1="598" y1="102" x2="102" y2="598" stroke="rgba(0,255,0,0.2)" stroke-width="1"/>
                
                <!-- Range indicators -->
                <text x="450" y="355" fill="#00ff00" font-size="10">100</text>
                <text x="500" y="355" fill="#00ff00" font-size="10">150</text>
                <text x="550" y="355" fill="#00ff00" font-size="10">200</text>
                
                <!-- Radar sweep line -->
                <g id="sweepGroup" style="animation: sweep 3s linear infinite;">
                    <line x1="350" y1="350" x2="650" y2="350" stroke="url(#sweepGradient)" stroke-width="2" opacity="0.8"/>
                </g>
                
                <!-- Gradient for sweep -->
                <defs>
                    <linearGradient id="sweepGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#00ff00;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#00ff00;stop-opacity:0" />
                    </linearGradient>
                    <radialGradient id="objectGradient" cx="50%" cy="50%" r="50%">
                        <stop offset="0%" style="stop-color:#ff4444;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#ff4444;stop-opacity:0.3" />
                    </radialGradient>
                    <radialGradient id="warningGradient" cx="50%" cy="50%" r="50%">
                        <stop offset="0%" style="stop-color:#ffaa00;stop-opacity:0.8" />
                        <stop offset="100%" style="stop-color:#ffaa00;stop-opacity:0.2" />
                    </radialGradient>
                </defs>
                
                <!-- Rover in center -->
                <g id="rover">
                    <rect x="340" y="335" width="20" height="30" fill="#333" stroke="#00ff00" stroke-width="2" rx="3"/>
                    <circle cx="350" cy="350" r="5" fill="#00ff00" opacity="0.8">
                        <animate attributeName="opacity" values="0.8;0.3;0.8" dur="2s" repeatCount="indefinite"/>
                    </circle>
                    <text x="350" y="385" fill="#00ff00" font-size="10" text-anchor="middle">ROVER</text>
                </g>
                
                <!-- Direction labels -->
                <text x="350" y="35" fill="#00ff00" font-size="12" text-anchor="middle">FRONT</text>
                <text x="670" y="355" fill="#00ff00" font-size="12" text-anchor="middle">RIGHT</text>
                <text x="350" y="685" fill="#00ff00" font-size="12" text-anchor="middle">BACK</text>
                <text x="25" y="355" fill="#00ff00" font-size="12" text-anchor="middle">LEFT</text>
                
                <!-- Sensor beams -->
                <g id="sensorBeams">
                    <!-- Front beam -->
                    <g id="frontBeam" opacity="0.6">
                        <polygon points="340,350 360,350 370,50 330,50" fill="rgba(0,255,0,0.1)" stroke="rgba(0,255,0,0.3)" stroke-width="1"/>
                    </g>
                    <!-- Right beam -->
                    <g id="rightBeam" opacity="0.6">
                        <polygon points="350,340 350,360 650,330 650,370" fill="rgba(0,255,0,0.1)" stroke="rgba(0,255,0,0.3)" stroke-width="1"/>
                    </g>
                    <!-- Back beam -->
                    <g id="backBeam" opacity="0.6">
                        <polygon points="340,350 360,350 370,650 330,650" fill="rgba(0,255,0,0.1)" stroke="rgba(0,255,0,0.3)" stroke-width="1"/>
                    </g>
                    <!-- Left beam -->
                    <g id="leftBeam" opacity="0.6">
                        <polygon points="350,340 350,360 50,330 50,370" fill="rgba(0,255,0,0.1)" stroke="rgba(0,255,0,0.3)" stroke-width="1"/>
                    </g>
                </g>
                
                <!-- Object indicators -->
                <g id="objectIndicators">
                    <circle id="frontObject" cx="350" cy="250" r="8" fill="url(#objectGradient)" opacity="0" stroke="#ff4444" stroke-width="2"/>
                    <circle id="rightObject" cx="450" cy="350" r="8" fill="url(#objectGradient)" opacity="0" stroke="#ff4444" stroke-width="2"/>
                    <circle id="backObject" cx="350" cy="450" r="8" fill="url(#objectGradient)" opacity="0" stroke="#ff4444" stroke-width="2"/>
                    <circle id="leftObject" cx="250" cy="350" r="8" fill="url(#objectGradient)" opacity="0" stroke="#ff4444" stroke-width="2"/>
                </g>
                
                <!-- Range rings for objects -->
                <g id="rangeRings" opacity="0">
                    <circle id="frontRing" cx="350" cy="250" r="20" fill="none" stroke="#ff4444" stroke-width="1" stroke-dasharray="5,5">
                        <animate attributeName="r" values="15;25;15" dur="1s" repeatCount="indefinite"/>
                    </circle>
                    <circle id="rightRing" cx="450" cy="350" r="20" fill="none" stroke="#ff4444" stroke-width="1" stroke-dasharray="5,5">
                        <animate attributeName="r" values="15;25;15" dur="1s" repeatCount="indefinite"/>
                    </circle>
                    <circle id="backRing" cx="350" cy="450" r="20" fill="none" stroke="#ff4444" stroke-width="1" stroke-dasharray="5,5">
                        <animate attributeName="r" values="15;25;15" dur="1s" repeatCount="indefinite"/>
                    </circle>
                    <circle id="leftRing" cx="250" cy="350" r="20" fill="none" stroke="#ff4444" stroke-width="1" stroke-dasharray="5,5">
                        <animate attributeName="r" values="15;25;15" dur="1s" repeatCount="indefinite"/>
                    </circle>
                </g>
            </svg>
        </div>

        <div class="data-panel">
            <div><strong>RADAR SYSTEM STATUS</strong></div>
            <div>Last Update: <span id="lastUpdate">--</span></div>
            <div>Total Readings: <span id="totalReadings">0</span></div>
            <div>System Status: <span id="systemStatus">OPERATIONAL</span></div>
            <div>Alert Level: <span id="alertLevel">NORMAL</span></div>
        </div>

        <div class="sensor-readings">
            <div><strong>SENSOR READINGS (cm)</strong></div>
            <div class="reading-item">
                <span>FRONT:</span>
                <span id="frontReading" class="safe">--</span>
            </div>
            <div class="reading-item">
                <span>RIGHT:</span>
                <span id="rightReading" class="safe">--</span>
            </div>
            <div class="reading-item">
                <span>BACK:</span>
                <span id="backReading" class="safe">--</span>
            </div>
            <div class="reading-item">
                <span>LEFT:</span>
                <span id="leftReading" class="safe">--</span>
            </div>
        </div>
    </div>

    <script>
        class RoverRadar {
            constructor() {
                this.isConnected = false;
                this.totalReadings = 0;
                this.lastData = null;
                this.init();
            }

            init() {
                this.updateConnectionStatus(false);
                this.startDataFetching();
            }

            async fetchData() {
                try {
                    const response = await fetch('/get_data');
                    if (!response.ok) throw new Error('Network response was not ok');
                    
                    const data = await response.json();
                    if (data && data.length > 0) {
                        this.processData(data[0]); // Get the most recent reading
                        this.updateConnectionStatus(true);
                    }
                } catch (error) {
                    console.error('Error fetching data:', error);
                    this.updateConnectionStatus(false);
                }
            }

            processData(reading) {
                this.lastData = reading;
                this.totalReadings++;

                // Update sensor readings display
                this.updateSensorReading('front', reading.front);
                this.updateSensorReading('right', reading.right);
                this.updateSensorReading('back', reading.back);
                this.updateSensorReading('left', reading.left);

                // Update radar visualization
                this.updateRadarVisualization(reading);

                // Update data panel
                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
                document.getElementById('totalReadings').textContent = this.totalReadings;
                document.getElementById('alertLevel').textContent = this.getAlertLevel(reading);
            }

            updateSensorReading(direction, distance) {
                const readingElement = document.getElementById(direction + 'Reading');
                readingElement.textContent = distance;

                // Update color based on distance
                readingElement.className = this.getDistanceClass(distance);
            }

            updateRadarVisualization(reading) {
                // Update object positions and visibility based on distance
                this.updateObjectIndicator('front', reading.front, 350, this.calculateY(reading.front));
                this.updateObjectIndicator('right', reading.right, this.calculateX(reading.right), 350);
                this.updateObjectIndicator('back', reading.back, 350, this.calculateY(reading.back, true));
                this.updateObjectIndicator('left', reading.left, this.calculateX(reading.left, true), 350);

                // Update beam colors based on readings
                this.updateBeamColor('front', reading.front);
                this.updateBeamColor('right', reading.right);
                this.updateBeamColor('back', reading.back);
                this.updateBeamColor('left', reading.left);
            }

            calculateX(distance, isLeft = false) {
                const maxDistance = 300; // Maximum sensor range
                const centerX = 350;
                const maxRadius = 250;
                
                const normalizedDistance = Math.min(distance, maxDistance) / maxDistance;
                const pixelDistance = normalizedDistance * maxRadius;
                
                return isLeft ? centerX - pixelDistance : centerX + pixelDistance;
            }

            calculateY(distance, isBack = false) {
                const maxDistance = 300; // Maximum sensor range
                const centerY = 350;
                const maxRadius = 250;
                
                const normalizedDistance = Math.min(distance, maxDistance) / maxDistance;
                const pixelDistance = normalizedDistance * maxRadius;
                
                return isBack ? centerY + pixelDistance : centerY - pixelDistance;
            }

            updateObjectIndicator(direction, distance, x, y) {
                const objectElement = document.getElementById(direction + 'Object');
                const ringElement = document.getElementById(direction + 'Ring');
                const rangeRings = document.getElementById('rangeRings');
                
                if (distance < 150) { // Show object if within 150cm
                    objectElement.setAttribute('cx', x);
                    objectElement.setAttribute('cy', y);
                    objectElement.style.opacity = '1';
                    
                    ringElement.setAttribute('cx', x);
                    ringElement.setAttribute('cy', y);
                    rangeRings.style.opacity = '1';

                    // Change color based on distance
                    if (distance < 30) {
                        objectElement.setAttribute('fill', 'url(#objectGradient)');
                        objectElement.setAttribute('stroke', '#ff4444');
                        ringElement.setAttribute('stroke', '#ff4444');
                    } else if (distance < 60) {
                        objectElement.setAttribute('fill', 'url(#warningGradient)');
                        objectElement.setAttribute('stroke', '#ffaa00');
                        ringElement.setAttribute('stroke', '#ffaa00');
                    } else {
                        objectElement.setAttribute('fill', 'rgba(0,255,0,0.5)');
                        objectElement.setAttribute('stroke', '#00ff00');
                        ringElement.setAttribute('stroke', '#00ff00');
                    }
                } else {
                    objectElement.style.opacity = '0';
                }
            }

            updateBeamColor(direction, distance) {
                const beamElement = document.getElementById(direction + 'Beam');
                let color, opacity;

                if (distance < 30) {
                    color = 'rgba(255,68,68,0.3)';
                    opacity = '0.8';
                } else if (distance < 60) {
                    color = 'rgba(255,170,0,0.2)';
                    opacity = '0.7';
                } else {
                    color = 'rgba(0,255,0,0.1)';
                    opacity = '0.6';
                }

                const polygon = beamElement.querySelector('polygon');
                polygon.setAttribute('fill', color);
                beamElement.style.opacity = opacity;
            }

            getDistanceClass(distance) {
                if (distance < 30) {
                    return 'alert';
                } else if (distance < 60) {
                    return 'warning';
                } else {
                    return 'safe';
                }
            }

            getAlertLevel(reading) {
                const minDistance = Math.min(reading.front, reading.right, reading.back, reading.left);
                
                if (minDistance < 30) {
                    return 'CRITICAL';
                } else if (minDistance < 60) {
                    return 'WARNING';
                } else {
                    return 'NORMAL';
                }
            }

            updateConnectionStatus(connected) {
                const statusElement = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                
                if (connected !== this.isConnected) {
                    this.isConnected = connected;
                    
                    if (connected) {
                        statusElement.className = 'connection-status connected';
                        statusText.textContent = 'RADAR ONLINE';
                        document.getElementById('systemStatus').textContent = 'OPERATIONAL';
                    } else {
                        statusElement.className = 'connection-status disconnected';
                        statusText.textContent = 'RADAR OFFLINE';
                        document.getElementById('systemStatus').textContent = 'ERROR';
                    }
                }
            }

            startDataFetching() {
                // Fetch data every 300ms for real-time updates
                setInterval(() => {
                    this.fetchData();
                }, 300);

                // Initial fetch
                this.fetchData();
            }
        }

        // Initialize the radar system when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new RoverRadar();
        });

        // Demo data for testing (remove in production)
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            let demoData = {'front': 116, 'right': 118, 'back': 109, 'left': 86};
            
            const originalFetch = window.fetch;
            window.fetch = function(url) {
                if (url === '/get_data') {
                    // Simulate realistic sensor variations
                    Object.keys(demoData).forEach(key => {
                        demoData[key] += Math.floor(Math.random() * 20 - 10);
                        demoData[key] = Math.max(15, Math.min(250, demoData[key]));
                    });
                    
                    return Promise.resolve({
                        ok: true,
                        json: () => Promise.resolve([{
                            id: 1,
                            timestamp: new Date().toISOString(),
                            ...demoData
                        }])
                    });
                }
                return originalFetch.apply(this, arguments);
            };
        }
    </script>
</body>
</html>